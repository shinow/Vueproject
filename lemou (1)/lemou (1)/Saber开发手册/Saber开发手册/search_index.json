[{"path":"序.md","content":"## Saber简介\n* Saber是SpringBlade前端UI框架，主要选型技术为Vue、VueX、Avue、Element-UI。\n* 本手册主要讲解如何在Saber平台下开发业务模块，同时也是Vue、VueX、Avue入门的绝佳选择。\n\n## SpringBlade简介\n* SpringBlade 是由一个商业级项目升级优化而来的SpringCloud微服务架构，采用Java8 API重构了业务代码，完全遵循阿里巴巴编码规范。\n* 采用Spring Boot 2 、Spring Cloud Greenwich 、Mybatis 等核心技术，同时提供基于React和Vue的两个前端框架用于快速搭建企业级的微服务系统平台。\n* SpringBlade 致力于创造新颖的开发模式，将开发中遇到的痛点、生产中所踩的坑整理归纳，并将解决方案都融合到框架中。\n\n## 说明\n本手册主要讲解前端技术栈，还需要后端的同学可移步：https://www.kancloud.cn/smallchill/blade\n\n## 官网\n* 官网地址： [BladeX](https://bladex.vip)\n## 项目地址\n* 项目地址：[SpringBlade](https://gitee.com/smallc/SpringBlade)\r\n* 前端UI项目地址(基于Vuet)：[Saber](https://gitee.com/smallc/Saber)\r\n* 前端UI项目地址(基于React)：[Sword](https://gitee.com/smallc/Sword)\r\n* 核心框架项目地址：[BladeTool](https://github.com/chillzhuang/blade-tool.git)\r\n* 交流群：`477853168`\n## 主要特性\n* 采用前后端分离的模式，前端开源两个框架：[Sword](https://gitee.com/smallc/Sword)(基于 React、Ant Design)、[Saber](https://gitee.com/smallc/Saber)(基于 Vue、Element-UI)\n*   后端采用SpringCloud全家桶，并同时对其基础组件做了高度的封装，单独开源出一个框架：[BladeTool](https://github.com/chillzhuang/blade-tool)\n*   [BladeTool](https://github.com/chillzhuang/blade-tool)已推送至Maven中央库，直接引入即可，减少了工程的臃肿，也可更注重于业务开发\n*   集成Sentinel从流量控制、熔断降级、系统负载等多个维度保护服务的稳定性。\n*   注册中心、配置中心选型Nacos，为工程瘦身的同时加强各模块之间的联动。\n*   使用Traefik进行反向代理，监听后台变化自动化应用新的配置文件。\n*   极简封装了多租户底层，用更少的代码换来拓展性更强的SaaS多租户系统。\n*   借鉴OAuth2，实现了多终端认证系统，可控制子系统的token权限互相隔离。\n*   借鉴Security，封装了Secure模块，采用JWT做Token认证，可拓展集成Redis等细颗粒度控制方案。\n*   稳定生产了一年，经历了从Camden -> Greenwich的技术架构，也经历了从fat jar -> docker -> k8s + jenkins的部署架构\n*   项目分包明确，规范微服务的开发模式，使包与包之间的分工清晰。\n\n## 工程结构\r\n``` \r\nSpringBlade\r\n├── blade-auth -- 授权服务提供\r\n├── blade-common -- 常用工具封装包\r\n├── blade-gateway -- Spring Cloud 网关\r\n├── blade-ops -- 运维中心\r\n├    ├── blade-admin -- spring-cloud后台管理\r\n├    └── blade-develop -- 代码生成\r\n├── blade-service -- 业务模块\r\n├    ├── blade-desk -- 工作台模块 \r\n├    ├── blade-log -- 日志模块 \r\n├    ├── blade-system -- 系统模块 \r\n├    └── blade-user -- 用户模块 \r\n├── blade-service-api -- 业务模块api封装\r\n├    ├── blade-desk-api -- 工作台api \r\n├    ├── blade-dict-api -- 字典api \r\n├    ├── blade-system-api -- 系统api \r\n└──  └── blade-user-api -- 用户api \r\n```\n```\nblade-tool\n├── blade-core-boot -- 业务包综合模块\n├── blade-core-cloud -- 分布式核心模块\n├── blade-core-launch -- 基础启动模块\n├── blade-core-log -- 日志封装模块 \n├── blade-core-mybatis -- mybatis拓展封装模块 \n├── blade-core-secure -- 安全模块 \n├── blade-core-swagger -- swagger拓展封装模块 \n├── blade-core-transaction -- 分布式事务核心模块\n└── blade-core-tool -- 工具包模块 \n```\n## 界面一览\r\n![](images/screenshot_1569335378654.png)\n![](images/screenshot_1569335383692.png)\n![](images/screenshot_1569335389314.png)\n![](images/screenshot_1569335394017.png)\n![](images/screenshot_1569335399324.png)\n![](images/screenshot_1569335408576.png)\n![](images/screenshot_1569335413698.png)\n![](images/screenshot_1569335419478.png)\n![](images/screenshot_1569335190203.png)\n![](images/screenshot_1569335225774.png)\n![](images/screenshot_1569335246905.png)\n![](images/screenshot_1569335260806.png)\n![](images/screenshot_1569335285637.png)\n![](images/screenshot_1569335303963.png)","title":"序"},{"path":"快速开始.md","content":"[环境要求](%E7%8E%AF%E5%A2%83%E8%A6%81%E6%B1%82.md)\n[环境准备](%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87.md)\n[工程导入](%E5%B7%A5%E7%A8%8B%E5%AF%BC%E5%85%A5.md)\n[工程运行](%E5%B7%A5%E7%A8%8B%E8%BF%90%E8%A1%8C.md)\n","title":"快速开始"},{"path":"环境要求.md","content":"## 基础开发环境\n* NodeJs: 10.15.0+\r\n* Npm: 5.6.0+\n\n## 推荐IDE\n* Visual Studio Code\n* IntelliJ WebStorm （本文将以此ide进行演示操作）\n","title":"环境要求"},{"path":"环境准备.md","content":"## 基础环境安装\n本文适合有一定基础的小伙伴，所以windows和mac下的nodejs默认您已有能力安装\n","title":"环境准备"},{"path":"工程导入.md","content":"# 前端安装\n## 复制git地址\n1.  进入`Saber`项目首页：\n* 开源版：[https://gitee.com/smallc/Saber](https://gitee.com/smallc/Saber)\n* 商业版：[https://gitee.ltd/blade/Saber](https://gitee.ltd/blade/Saber)\n2.  复制`Saber`的`git`地址\n* 开源版：![](images/screenshot_1569298213733.png)\n* 商业版：![](images/screenshot_1569334001506.png)\n3. 进入对应目录后克隆代码(windows可以用git bash客户端)\n![](images/screenshot_1569298261754.png)\n\n## 安装工程\n1. 安装yarn并配置淘宝源\n![](images/screenshot_1569298415861.png)\n~~~cpp\n> npm install -g yarn --registry=https://registry.npm.taobao.org\n~~~\n~~~cpp\n> yarn config set registry https://registry.npm.taobao.org -g\n~~~\n\n2. 进入Saber根目录进行安装\n~~~\n> cd Saber\n~~~\n~~~\n> yarn install\n~~~\n![](images/screenshot_1569298617143.png)\n\n\n## 导入工程\n1. 打开WebStorm，点击File选择Open\n![](images/screenshot_1569333651316.png)\n2. 找到对应目录的工程，并打开\n![](images/screenshot_1569333695288.png)\n3. 看到如下界面则说明导入成功\n![](images/screenshot_1569333710123.png)\n\n\n\n","title":"工程导入"},{"path":"工程运行.md","content":"## 命令行运行\n1. 运行工程\n~~~\n> yarn run serve\n~~~\n![](images/screenshot_1569298753510.png)\n2. 查看红框内的地址并打开浏览器访问,出现如下界面则说明安装启动成功\n![](images/screenshot_1569298796777.png)\n\n<br>\n\n## IDE运行\n1. 使用webstorm、vscode自带的启动器启动项目\n![](images/screenshot_1569333747599.png)\n2. 看到如下界面则说明启动成功\n![](images/screenshot_1569333827418.png)\n3. 查看红框内的地址并打开浏览器访问,出现如下界面则说明安装启动成功\n![](images/screenshot_1569298796777.png)\n\n<br>\n\n# 后端安装\n* 后端启动请参考后端开发手册：[https://www.kancloud.cn/smallchill/blade/913213](https://www.kancloud.cn/smallchill/blade/913213)\n* 若想不使用cloud，使用简易启动，可以直接下载boot版本启动 （注意需要将前后端的开源、商业版本保持一致）\n* 开源版cloud地址：[https://gitee.com/smallc/SpringBlade](https://gitee.com/smallc/SpringBlade)\n* 开源版boot地址：[https://gitee.com/smallc/SpringBlade/tree/2.0-boot/](https://gitee.com/smallc/SpringBlade/tree/2.0-boot/)\n* 商业版cloud地址：[https://gitee.ltd/blade/BladeX](https://gitee.ltd/blade/BladeX)\n* 商业版boot地址：[https://gitee.ltd/blade/BladeX-Boot](https://gitee.ltd/blade/BladeX-Boot)","title":"工程运行"},{"path":"技术基础.md","content":"[ES6](ES6.md)\n[Vue](Vue.md)\n[Vuex](Vuex.md)\n[ElementUI](ElementUI.md)\n[Avue](Avue.md)\n","title":"技术基础"},{"path":"ES6.md","content":"## 简介\nECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。\n\n## 学习资料\n*  ECMAScript 6 入门 ： [http://es6.ruanyifeng.com/#README](http://es6.ruanyifeng.com/#README)","title":"ES6"},{"path":"Vue.md","content":"## 简介\nVue (读音 /vjuː/，类似于**view**) 是一套用于构建用户界面的**渐进式框架**。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与[现代化的工具链](https://cn.vuejs.org/v2/guide/single-file-components.html)以及各种[支持类库](https://github.com/vuejs/awesome-vue#libraries--plugins)结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。\n\n## 学习资料\n*  Vue官方文档：[https://cn.vuejs.org/v2/guide/](https://cn.vuejs.org/v2/guide/)","title":"Vue"},{"path":"Vuex.md","content":"## 简介\nVuex 是一个专为 Vue.js 应用程序开发的**状态管理模式**。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。Vuex 也集成到 Vue 的官方调试工具[devtools extension](https://github.com/vuejs/vue-devtools)，提供了诸如零配置的 time-travel 调试、状态快照导入导出等高级调试功能。\n\n## 学习资料\n*  Vuex官方文档：[https://vuex.vuejs.org/zh/guide/](https://vuex.vuejs.org/zh/guide/)","title":"Vuex"},{"path":"ElementUI.md","content":"## 简介\nElement UI 是一套为开发者、设计师和产品经理准备的开源组件库，旨在快速搭建页面。它基于 Vue 2.0 开发，并提供了配套的设计资源，充分满足可定制化的需求。\n\n## 学习资料\n*  ElementUI官方文档：[https://element.eleme.cn/#/zh-CN/component/installation](https://element.eleme.cn/#/zh-CN/component/installation)","title":"ElementUI"},{"path":"Avue.md","content":"## 简介\nAvue.js2.0是基于现有的element-ui库进行的二次封装，简化一些繁琐的操作，核心理念为数据驱动视图,主要的组件库针对table表格和form表单场景，同时衍生出更多企业常用的组件，达到高复用，容易维护和扩展的框架，同时内置了丰富了数据展示组件，让开发变得更加容易。\n\n## 学习资料\n*  Avue官方文档：[https://avuejs.com/doc/installation](https://avuejs.com/doc/installation)","title":"Avue"},{"path":"开发初探.md","content":"[第一个页面](%E7%AC%AC%E4%B8%80%E4%B8%AA%E9%A1%B5%E9%9D%A2.md)\n[ElementUI组件](ElementUI%E7%BB%84%E4%BB%B6.md)\n[自定义组件](%E8%87%AA%E5%AE%9A%E4%B9%89%E7%BB%84%E4%BB%B6.md)\n[Mock数据](Mock%E6%95%B0%E6%8D%AE.md)\n[API调用](API%E8%B0%83%E7%94%A8.md)\n[API结合Mock加载组件](API%E7%BB%93%E5%90%88Mock%E5%8A%A0%E8%BD%BD%E7%BB%84%E4%BB%B6.md)\n[第一个CRUD](%E7%AC%AC%E4%B8%80%E4%B8%AACRUD.md)\n","title":"开发初探"},{"path":"第一个页面.md","content":"## 新建页面\n* 进入`/src/views`目录新建`/demo/demo.vue`文件\n![](images/screenshot_1569336378771.png)\n\n## 创建路由\n* 前往`/src/router/views/index.js`配置对应路由\n![](images/screenshot_1569336270771.png)\n\n## 系统访问\n*  启动工程访问：[http://localhost:1888/#/demo/index](http://localhost:1888/#/demo/index) 发现页面渲染成功\n![](images/screenshot_1569336328603.png)\n* 修改demo.vue文件内容，再次刷新界面，发现重新渲染成功\n![](images/screenshot_1569336482817.png)\n![](images/screenshot_1569336493124.png)\n\n## 后续\n第一个页面我们新增成功了，那么下一章让我们来学习下如何引入ElementUI的组件并简单使用","title":"第一个页面"},{"path":"ElementUI组件.md","content":"## ElementUI官方文档\n文档地址：[https://element.eleme.cn/#/zh-CN/component/quickstart](https://element.eleme.cn/#/zh-CN/component/quickstart)\n\n## 最简单的组件引入\n1. 我们找到basic模块下的button，查看对应文档\n![](images/screenshot_1569336723553.png)\n![](images/screenshot_1569336742869.png)\n2. 稍做修改引入我们的Demo页面\n![](images/screenshot_1569336888739.png)\n3. 打开系统查看效果\n![](images/screenshot_1569336901787.png)\n\n## 常见的Select组件引入\n1. 我们找到常用的select，查看文档\n![](images/screenshot_1569336938556.png)\n2. 稍做修改引入我们的Demo页面\n![](images/screenshot_1569337340913.png)\n3. 打开系统查看效果\n![](images/screenshot_1569337044840.png)\n4. 点击对应选项后console控制台答应信息成功\n![](images/screenshot_1569337377492.png)\n\n## 注意\n* select组件的for循环加载`<el-option>`以及`@change`执行`onChange`方法是vue中最基础的知识点，这里不再针对基础源码进行赘述\n* 若还不理解请务必先完整看两遍es6的文档以及vue的文档\n* es6：[http://es6.ruanyifeng.com/#README](http://es6.ruanyifeng.com/#README)\n* vue：[https://cn.vuejs.org/v2/guide/](https://cn.vuejs.org/v2/guide/)\n\n## 后记\n* ElementUI的组件质量非常高，数量也多，在这个章节只是简单的教大家如何引入组件\n* 若已有基础可直接略过，如果是新手，则强烈推荐将ElementUI的每个组件都像刚刚这样一个一个引入并且测试效果，这样必定会给未来打下扎实的基础，***磨刀不误砍柴工***，请大家谨记！～\n","title":"ElementUI组件"},{"path":"自定义组件.md","content":"## 前言\n一般来说，ElementUI提供的都是基础组件，而在我们进行业务开发的时候，会经常有多个组件组合在一起并且会被高频调用的情况，所以这时候就用到自定义组件，那么下面我们来看下如果制作一个最简单的自定义组件。\n\n## 自定义组件制作\n1. 一般自定义组件都放在components文件夹中，找到后打开目录，新建一个demo文件夹和一个x-button的vue文件\n![](images/screenshot_1569408193710.png)\n2. 我们加上最简单逻辑的代码，封装一个组件`x-button`，使之加载后自带点击事件\n![](images/screenshot_1569456628582.png)\n3. 我们再到一开始的Demo页面引入这个自定义组件，查看是否生效\n4. 这里有两种方式引入自定义组件，一种是局部引入，一种是全局引入，下面我们来看一下两种方式分别如何操作\n* 局部引入\n![](images/screenshot_1569457410039.png)\n![](images/screenshot_1569457637903.png)\n![](images/screenshot_1569457390045.png)\n这里可以看到，x-button.vue文件name设定为`x-button`，在demo.vue引入的时候为驼峰的xButton，挂在在components属性下，这样一来便可以使用x-button组件直接引入了。\n打开页面，点击按钮发现方法执行成功\n![](images/screenshot_1569457511714.png)\n* 全局引入\n![](images/screenshot_1569473587771.png)\n![](images/screenshot_1569473599779.png)\n打开页面，发现效果与局部加载一致\n![](images/screenshot_1569473556068.png)\n\n## 结尾语\n看到这，相信大家已经知道如何自定义一个最简单而又功能兼备的组件，掌握其中主要知识点，再在这基础上自行拓展，相信大家都可以写出很棒都定制型组件！","title":"自定义组件"},{"path":"Mock数据.md","content":"## Mock简介\n* Mock是模拟对象的意思，用于进行被测组件对外依赖的模拟。\n* Mock 是测试驱动开发必备之利器, 只要有状态, 有依赖, 做单元测试就不能没有 Mock  \n* 在 API 或 集成测试的时候, 如果依赖于第三方的 API, 也时常使用 mock server 或 mock proxy\n\n## 如何使用\nSaber已经完美集成了Mock，可以很方便地模拟动静态数据，达到对接服务端的真实性与准确性。下面我们来看下如何在Saber中使用Mock\n1. 我们到mock文件夹下创建demo.js\n![](images/screenshot_1569476662126.png)\n2. 在mock文件夹下的index.js配置加载\n![](images/screenshot_1569476899874.png)\n3. 这样一来，一个简单的mockAPI就配置好了\n4. 更多Mock详细教程请看：[https://segmentfault.com/a/1190000014844604](https://segmentfault.com/a/1190000014844604)","title":"Mock数据"},{"path":"API调用.md","content":"## 前言\n* 前端开发中最重要的便是api调用，从服务端拉取数据进行业务操作，完毕之后提交数据至服务端\n* 这个流程几乎涵盖了整个系统\n* 下面我们来学习下标准的api调用应该如何编写\n* 同时看下如何和我们的自定义组件结合起来\n\n\n## 定义一个api\n1. 我们到api文件夹下创建demo.js，内容如下\n![](images/screenshot_1569485783945.png)\n2. 工程封装了`axios`方法，将常用的方法都封装好，方便大家直接调用\n\n## 调用api\n1. 我们准备让这个方法在页面初次加载的时候调用，并把获取到的数据打印出来\n2. 进入我们编写的Demo页面，编写一个测试方法\n![](images/screenshot_1569485960054.png)\n* `import xx from xxx` 将我们刚刚编写的api方法引入\n* `created` 属于vue生命周期中`创建执行`\n* `getDetail` 在页面加载的时候执行，并且将返回的值打印在控制台\n3. 打开系统刷新页面，发现控制台打印与mock设定一致\n![](images/screenshot_1569487271885.png)\n\n## 使用同步调用api\n很多业务场景，经常会有同时几个接口调用共同依赖的场景，若超过3个的话，都写在.then方法里进行操作，代码会变得非常不优雅，耦合度也高。下面我们来尝试下使用同步操作代码\n1. demo增加mock接口test\n![](images/screenshot_1569487646502.png)\n2. 对应api增加接口定义\n![](images/screenshot_1569487665536.png)\n3. 更改代码，单独抽离出一个方法init，用于同步代码的操作。同时将init的返回类型打印出来\n![](images/screenshot_1569488116259.png)\n4. 打开系统查看控制台打印，可以看到两条信息都打印成功，而且是按顺序加载。这样解耦了多个接口下都操作，代码看起来更清爽，可读性更高。\n![](images/screenshot_1569488082463.png)\n5. 可以看到，返回都是一个Promise对象，具体介绍，请看：https://www.imooc.com/article/20580\n6. 还有一点需要注意的是，如果需要用到promise，那么方法前必须带有`async`关键字，否则将失效\n\n<br>\n<br>\n<br>\n\n## 放上相关代码\n* 希望大家都能把代码都手动敲出来，而不是直接复制粘贴\n* `/mock/demo.js` ：\n~~~\nimport Mock from 'mockjs'\n\nfunction getFakeDetail() {\n  const json = {code: 200, success: true, msg: '操作成功'};\n  json.data = \"测试mock返回\";\n  return json;\n}\n\nfunction getFakeTestDetail() {\n  const json = {code: 200, success: true, msg: '操作成功'};\n  json.data = \"测试mock test返回\";\n  return json;\n}\n\nexport default ({mock}) => {\n  if (!mock) return;\n\n  Mock.mock(/\\/api\\/demo\\/detail/, 'get', getFakeDetail);\n  Mock.mock(/\\/api\\/demo\\/test-detail/, 'get', getFakeTestDetail);\n\n}\n\n~~~\n\n* `/mock/index.js` :\n~~~\nimport user from './user';\nimport menu from './menu';\nimport demo from './demo';\n\n/**\n * 模拟数据mock\n *\n * mock是否开启模拟数据拦截\n */\n\nuser({mock: true});\n\nmenu({mock: true});\n\ndemo({mock: true});\n\n~~~\n\n\n\n* `/api/demo/demo.js` : \n~~~\nimport request from '@/router/axios';\n\nexport const getDetail = () => {\n  return request({\n    url: '/api/demo/detail',\n    method: 'get',\n  })\n}\n\nexport const getTestDetail = () => {\n  return request({\n    url: '/api/demo/test-detail',\n    method: 'get',\n  })\n}\n\n~~~\n\n\n* `/views/demo/demo.vue` : \n~~~\n<template>\n  <div>\n    <h1>hello saber! im bladex!</h1>\n\n    <x-button></x-button>\n  </div>\n</template>\n\n<script>\n  import {getDetail, getTestDetail} from '@/api/demo/demo';\n\n  export default {\n    name: \"demo\",\n    data() {\n      return {\n        options: [],\n        value: ''\n      }\n    },\n    created() {\n      const promise = this.init();\n      console.log(promise);\n    },\n    methods: {\n      async init() {\n        const res = await getDetail();\n        if (res.data.success) {\n          console.log(res.data.data);\n        } else {\n          console.log(res.data.msg);\n        }\n        const resTest = await getTestDetail();\n        if (resTest.data.success) {\n          console.log(resTest.data.data);\n        } else {\n          console.log(resTest.data.msg);\n        }\n      },\n      onChange() {\n        console.log(this.value)\n      },\n    }\n  }\n</script>\n\n<style scoped>\n\n</style>\n\n~~~\n","title":"API调用"},{"path":"API结合Mock加载组件.md","content":"## 前言\n* 现在我们结合之前所学，将自定义组件、mock数据、api调用整合在一起。\n* 拓展x-button组件，在外部传入参数，组件内部点击后调用api后将返回打印至控制台\n\n## 开始集成\n1. 我们将Demo模块中的部分代码拷贝至x-button组件中\n![](images/screenshot_1569488723264.png)\n2. 可以看到，现在是每次点击按钮后，进行调用接口，并且将返回打印在控制台中\n3. 打开系统点击按钮查看控制台，点击两次按钮发现调用成功\n![](images/screenshot_1569488778358.png)\n\n## 放上相关代码\n* 希望大家都能把代码都手动敲出来，而不是直接复制粘贴\n* `/views/demo/demo.vue` ：\n~~~\n<template>\n  <div>\n    <h1>hello saber! im bladex!</h1>\n\n    <x-button></x-button>\n  </div>\n</template>\n\n<script>\n\n  export default {\n    name: \"demo\",\n    data() {\n      return {\n        options: [],\n        value: ''\n      }\n    },\n    created() {\n    },\n    methods: {\n      onChange() {\n        console.log(this.value)\n      },\n    }\n  }\n</script>\n\n<style scoped>\n\n</style>\n\n~~~\n\n* `/components/demo/x-button.vue` ：\n~~~\n<template>\n  <div>\n    <el-button type=\"primary\" @click=\"handleSubmit\">按钮点击</el-button>\n  </div>\n</template>\n\n<script>\n  import {getDetail, getTestDetail} from '@/api/demo/demo';\n\n  export default {\n    name: 'x-button',\n    methods: {\n      async init() {\n        const res = await getDetail();\n        if (res.data.success) {\n          console.log(res.data.data);\n        } else {\n          console.log(res.data.msg);\n        }\n        const resTest = await getTestDetail();\n        if (resTest.data.success) {\n          console.log(resTest.data.data);\n        } else {\n          console.log(resTest.data.msg);\n        }\n      },\n      handleSubmit() {\n        console.log(\"按钮点击了\");\n        const promise = this.init();\n        console.log(promise);\n      }\n    }\n  }\n</script>\n\n<style scoped>\n\n</style>\n\n~~~\n","title":"API结合Mock加载组件"},{"path":"第一个CRUD.md","content":"[模块准备](%E6%A8%A1%E5%9D%97%E5%87%86%E5%A4%87.md)\n[列表页](%E5%88%97%E8%A1%A8%E9%A1%B5.md)\n[新增页](%E6%96%B0%E5%A2%9E%E9%A1%B5.md)\n[修改页](%E4%BF%AE%E6%94%B9%E9%A1%B5.md)\n[详情页](%E8%AF%A6%E6%83%85%E9%A1%B5.md)\n[删除操作](%E5%88%A0%E9%99%A4%E6%93%8D%E4%BD%9C.md)\n","title":"第一个CRUD"},{"path":"模块准备.md","content":"## 前言\n* 这一节是重点内容，将向大家介绍如何在saber上使用原生ElementUI进行开发一个CRUD的完整模块\n* 下一节则会为大家带来saber基于avue的json数据驱动的CRUD模块\n* 开发效率会成倍提升，真正享受极速开发带来的乐趣\n* 在开发之前，我们需要配置一下mock数据，根据接口返回所需的数据\n\n## 配置菜单\n1. 进入菜单管理模块\n![](images/screenshot_1569489686240.png)\n2. 新建测试模块\n![](images/screenshot_1569490061649.png)\n![](images/screenshot_1569490453665.png)\n3. 新建测试模块的增、删、改、查按钮\n![](images/screenshot_1569491013899.png)\n![](images/screenshot_1569491103493.png)\n![](images/screenshot_1569491087631.png)\n![](images/screenshot_1569491149184.png)\n![](images/screenshot_1569491170585.png)\n4. 进入角色管理模块，进行权限分配\n![](images/screenshot_1569491213360.png)\n5. 这时刷新菜单我们便可以看到刚刚新增的菜单了\n![](images/screenshot_1569491240875.png)\n\n\n\n## 配置mock\n1. 创建blog.js的mock文件\n~~~\nimport Mock from 'mockjs'\n\nfunction getFakeList() {\n  const json = {code: 200, success: true, msg: '操作成功'};\n  const list = [];\n  list.push(\n    {\n      id: '1',\n      title: '博客标题1',\n      time: '2019.09.26',\n      content: '博客内容1',\n    },\n    {\n      id: '2',\n      title: '博客标题2',\n      time: '2019.09.26',\n      content: '博客内容2',\n    }\n  );\n  json.data = {\n    total: 10,\n    size: 10,\n    current: 1,\n    searchCount: true,\n    pages: 1,\n    records: list,\n  };\n  return json;\n}\n\nfunction getFakeDetail() {\n  const json = {code: 200, success: true, msg: '操作成功'};\n  json.data = {\n    id: '1',\n    title: '博客标题1',\n    time: '2019.09.26',\n    content: '博客内容1',\n  };\n  return json;\n}\n\nfunction fakeSuccess() {\n  return {code: 200, success: true, msg: '操作成功'};\n}\n\nexport default ({mock}) => {\n  if (!mock) return;\n  Mock.mock(/\\/api\\/blade-desk\\/blog\\/list/, 'get', getFakeList);\n\n  Mock.mock(/\\/api\\/blade-desk\\/blog\\/detail/, 'get', getFakeDetail);\n\n  Mock.mock(/\\/api\\/blade-desk\\/blog\\/submit/, 'post', fakeSuccess);\n\n  Mock.mock(/\\/api\\/blade-desk\\/blog\\/remove/, 'post', fakeSuccess);\n\n}\n\n~~~\n2. 前往index.js进行开启\n![](images/screenshot_1569491837553.png)\n3. 创建blog.js的api文件\n~~~\nimport request from '@/router/axios';\n\nexport const getList = (current, size, params) => {\n  return request({\n    url: '/api/blade-desk/blog/list',\n    method: 'get',\n    params: {\n      ...params,\n      current,\n      size,\n    }\n  })\n}\n\nexport const getDetail = (id) => {\n  return request({\n    url: '/api/blade-desk/blog/detail',\n    method: 'get',\n    params: {\n      id,\n    }\n  })\n}\n\nexport const remove = (ids) => {\n  return request({\n    url: '/api/blade-desk/blog/remove',\n    method: 'post',\n    params: {\n      ids,\n    }\n  })\n}\n\nexport const submit = (row) => {\n  return request({\n    url: '/api/blade-desk/blog/submit',\n    method: 'post',\n    data: row\n  })\n}\n\n~~~\n4. 基础工作已经完毕，下面我们就开始编写一个基础的crud模块吧","title":"模块准备"},{"path":"列表页.md","content":"## 新建列表页面\n1. 我们先做一个最简单的列表页面\n2. 列表页面完整代码如下：\n~~~\n<template>\n  <basic-container>\n    <el-row>\n      <el-col :span=\"24\">\n        <div class=\"tool-box\">\n          <el-button type=\"primary\" icon=\"el-icon-circle-plus-outline\" size=\"small\" @click=\"handleAdd\">新增</el-button>\n          <el-button type=\"danger\" icon=\"el-icon-delete\" size=\"small\" @click=\"handleMultiDelete\">批量删除</el-button>\n        </div>\n      </el-col>\n    </el-row>\n    <el-row>\n      <el-table\n        :data=\"data\"\n        @selection-change=\"selectChange\"\n        style=\"width: 100%\">\n        <el-table-column\n          prop=\"id\"\n          type=\"selection\"\n          width=\"55\">\n        </el-table-column>\n        <el-table-column\n          prop=\"title\"\n          label=\"标题\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column\n          prop=\"content\"\n          label=\"内容\">\n        </el-table-column>\n        <el-table-column\n          prop=\"time\"\n          label=\"日期\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column label=\"操作\" fixed=\"right\" width=\"250\">\n          <template slot-scope=\"scope\">\n            <el-button\n              size=\"mini\"\n              type=\"\"\n              plain\n              @click=\"handleView(scope.$index, scope.row)\">查看\n            </el-button>\n            <el-button\n              size=\"mini\"\n              type=\"primary\"\n              plain\n              @click=\"handleEdit(scope.$index, scope.row)\">编辑\n            </el-button>\n            <el-button\n              size=\"mini\"\n              type=\"danger\"\n              @click=\"handleDelete(scope.$index, scope.row)\">删除\n            </el-button>\n          </template>\n        </el-table-column>\n      </el-table>\n    </el-row>\n    <el-row>\n      <el-pagination\n        background\n        :page-sizes=\"[10, 20, 30, 50]\"\n        :page-size=\"10\"\n        layout=\"total, sizes, prev, pager, next, jumper\"\n        @size-change=\"sizeChange\"\n        @current-change=\"currentChange\"\n        :total=\"page.total\">\n      </el-pagination>\n    </el-row>\n  </basic-container>\n</template>\n\n<script>\n  import {getList} from '@/api/demo/blog'\n\n  export default {\n    data() {\n      return {\n        data: [],\n        multiSelection: [],\n        page: {\n          pageSize: 10,\n          currentPage: 1,\n          total: 0\n        },\n      }\n    },\n    created() {\n      this.onLoad();\n    },\n    methods: {\n      onLoad() {\n        getList().then(res => {\n          this.data = res.data.data.records;\n          this.page.total = res.data.data.total;\n        })\n      },\n      selectChange(val) {\n        this.multiSelection = val\n      },\n      currentChange(currentPage){\n        this.page.currentPage = currentPage;\n      },\n      sizeChange(pageSize){\n        this.page.pageSize = pageSize;\n      },\n      handleAdd() {\n        console.log(\"add\")\n      },\n      handleView(index, row) {\n        console.log(\"view\");\n        console.log(index);\n        console.log(row);\n      },\n      handleEdit(index, row) {\n        console.log(\"edit\");\n        console.log(index);\n        console.log(row);\n      },\n      handleDelete(index, row) {\n        console.log(\"delete\");\n        console.log(index);\n        console.log(row);\n      },\n      handleMultiDelete() {\n        console.log(\"multi-delete\")\n      },\n    }\n  }\n</script>\n\n~~~\n3. 我们来详细分析每一个代码块的作用及目的\n* `<basic-container>` 标签将整个页面包裹在定义好样式的容器内，另布局界面更美观\n* 我们改造下demo.vue文件便能看到比之前更好的效果\n![](images/screenshot_1569560572959.png)\n![](images/screenshot_1569560588674.png)\n* 如下代码代表在页面新建一行，定义两个按钮，并用`@click`指定了对应的点击事件\n~~~\n<el-row>\n  <el-col :span=\"24\">\n    <div class=\"tool-box\">\n      <el-button type=\"primary\" icon=\"el-icon-circle-plus-outline\" size=\"small\" @click=\"handleAdd\">新增</el-button>\n      <el-button type=\"danger\" icon=\"el-icon-delete\" size=\"small\" @click=\"handleMultiDelete\">批量删除</el-button>\n    </div>\n  </el-col>\n</el-row>\n~~~\n* 如下代码代表在页面定义表格控件，用`:data`绑定指定的数据，以及用`@selection-change`绑定选中后的事件\n~~~\n<el-table\n  :data=\"data\"\n  @selection-change=\"selectChange\"\n  style=\"width: 100%\">\n~~~\n* 如下代码代表在`el-table`组件内定义了`选项框`、`标题`、`内容`、`日期`的字段\n~~~\n<el-table-column\n  prop=\"id\"\n  type=\"selection\"\n  width=\"55\">\n</el-table-column>\n<el-table-column\n  prop=\"title\"\n  label=\"标题\"\n  width=\"180\">\n</el-table-column>\n<el-table-column\n  prop=\"content\"\n  label=\"内容\">\n</el-table-column>\n<el-table-column\n  prop=\"time\"\n  label=\"日期\"\n  width=\"180\">\n</el-table-column>\n~~~\n* 如下代码代表定加入操作栏，并且定义了`查看`、`编辑`、`删除`三个按钮以及他们对应的点击事件\n~~~\n<el-table-column label=\"操作\" fixed=\"right\" width=\"250\">\n  <template slot-scope=\"scope\">\n    <el-button\n      size=\"mini\"\n      type=\"\"\n      plain\n      @click=\"handleView(scope.$index, scope.row)\">查看\n    </el-button>\n    <el-button\n      size=\"mini\"\n      type=\"primary\"\n      plain\n      @click=\"handleEdit(scope.$index, scope.row)\">编辑\n    </el-button>\n    <el-button\n      size=\"mini\"\n      type=\"danger\"\n      @click=\"handleDelete(scope.$index, scope.row)\">删除\n    </el-button>\n  </template>\n</el-table-column>\n~~~\n* 如下代码定义了分页组件，并绑定了`size-change`与`current-change`两个事件\n~~~\n<el-pagination\n  background\n  :page-sizes=\"[10, 20, 30, 50]\"\n  :page-size=\"10\"\n  layout=\"total, sizes, prev, pager, next, jumper\"\n  @size-change=\"sizeChange\"\n  @current-change=\"currentChange\"\n  :total=\"page.total\">\n</el-pagination>\n~~~\n* 如下代码则是定义了vue的各种事件，与table组件相互绑定\n~~~\n<script>\n  import {getList} from '@/api/demo/blog'\n\n  export default {\n    data() {\n      return {\n        data: [],\n        multiSelection: [],\n        page: {\n          pageSize: 10,\n          currentPage: 1,\n          total: 0\n        },\n      }\n    },\n    created() {\n      this.onLoad();\n    },\n    methods: {\n      onLoad() {\n        getList().then(res => {\n          this.data = res.data.data.records;\n          this.page.total = res.data.data.total;\n        })\n      },\n      selectChange(val) {\n        this.multiSelection = val\n      },\n      currentChange(currentPage){\n        this.page.currentPage = currentPage;\n      },\n      sizeChange(pageSize){\n        this.page.pageSize = pageSize;\n      },\n      handleAdd() {\n        console.log(\"add\")\n      },\n      handleView(index, row) {\n        console.log(\"view\");\n        console.log(index);\n        console.log(row);\n      },\n      handleEdit(index, row) {\n        console.log(\"edit\");\n        console.log(index);\n        console.log(row);\n      },\n      handleDelete(index, row) {\n        console.log(\"delete\");\n        console.log(index);\n        console.log(row);\n      },\n      handleMultiDelete() {\n        console.log(\"multi-delete\")\n      },\n    }\n  }\n</script>\n~~~\n\n4.  下面我们刷新页面，查看下具体效果\n![](images/screenshot_1569562018029.png)\n5. 我们发现分页距离表格太靠近了，这样不美观，需要做一下样式处理，在最下方加入如下样式\n~~~\n<style lang=\"scss\" scoped>\n  .el-pagination {\n    margin-top: 20px;\n  }\n</style>\n~~~\n6. 再次刷新页面，发现样式调整恰到好处\n![](images/screenshot_1569562278824.png)\n7. 最简单的列表页已经完成，下面几章我们来分别处理增改查三个对应的操作\n","title":"列表页"},{"path":"新增页.md","content":"## 新建表单\n1. 加入弹窗组件，并填上表单配置，完整代码如下\n~~~\n<template>\n  <basic-container>\n    <el-row>\n      <el-col :span=\"24\">\n        <div class=\"tool-box\">\n          <el-button type=\"primary\" icon=\"el-icon-circle-plus-outline\" size=\"small\" @click=\"handleAdd\">新增</el-button>\n          <el-button type=\"danger\" icon=\"el-icon-delete\" size=\"small\" @click=\"handleMultiDelete\">批量删除</el-button>\n        </div>\n      </el-col>\n    </el-row>\n    <el-row>\n      <el-table\n        :data=\"data\"\n        @selection-change=\"selectChange\"\n        style=\"width: 100%\">\n        <el-table-column\n          prop=\"id\"\n          type=\"selection\"\n          width=\"55\">\n        </el-table-column>\n        <el-table-column\n          prop=\"title\"\n          label=\"标题\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column\n          prop=\"content\"\n          label=\"内容\">\n        </el-table-column>\n        <el-table-column\n          prop=\"time\"\n          label=\"日期\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column label=\"操作\" fixed=\"right\" width=\"250\">\n          <template slot-scope=\"scope\">\n            <el-button\n              size=\"mini\"\n              type=\"\"\n              plain\n              @click=\"handleView(scope.$index, scope.row)\">查看\n            </el-button>\n            <el-button\n              size=\"mini\"\n              type=\"primary\"\n              plain\n              @click=\"handleEdit(scope.$index, scope.row)\">编辑\n            </el-button>\n            <el-button\n              size=\"mini\"\n              type=\"danger\"\n              @click=\"handleDelete(scope.$index, scope.row)\">删除\n            </el-button>\n          </template>\n        </el-table-column>\n      </el-table>\n    </el-row>\n    <el-row>\n      <el-pagination\n        background\n        :page-sizes=\"[10, 20, 30, 50]\"\n        :page-size=\"10\"\n        layout=\"total, sizes, prev, pager, next, jumper\"\n        @size-change=\"sizeChange\"\n        @current-change=\"currentChange\"\n        :total=\"page.total\">\n      </el-pagination>\n    </el-row>\n    <el-dialog :title=\"dialogTitle\" width=\"600px\" :visible.sync=\"formVisible\" @close=\"resetForm('blogForm')\">\n      <el-form :model=\"blog\" :rules=\"rules\" ref=\"blogForm\">\n        <el-form-item label=\"标题\" prop=\"title\" label-width=\"55px\">\n          <el-input v-model=\"blog.title\" autocomplete=\"off\"></el-input>\n        </el-form-item>\n        <el-form-item label=\"时间\" label-width=\"55px\">\n          <el-date-picker\n            v-model=\"blog.time\"\n            style=\"width: 100%;\"\n            type=\"date\"\n            value-format=\"yyyy-MM-dd\"\n            placeholder=\"选择日期\"\n            autocomplete=\"off\">\n          </el-date-picker>\n        </el-form-item>\n        <el-form-item label=\"内容\" label-width=\"55px\">\n          <el-input v-model=\"blog.content\" autocomplete=\"off\" type=\"textarea\" :rows=\"5\"></el-input>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"formVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"submitBlog('blogForm')\">确 定</el-button>\n      </div>\n    </el-dialog>\n  </basic-container>\n</template>\n\n<script>\n  import {getList, submit} from '@/api/demo/blog'\n\n  export default {\n    data() {\n      return {\n        // 是否显示\n        formVisible: false,\n        // dialog标题\n        dialogTitle: '',\n        // 列表数据\n        data: [],\n        // 选中的数据\n        multiSelection: [],\n        // 分页数据\n        page: {\n          pageSize: 10,\n          currentPage: 1,\n          total: 0\n        },\n        // 校验规则\n        rules: {\n          title: [\n            {required: true, message: '请输入标题', trigger: 'blur'},\n          ]\n        },\n        // 表单映射模型\n        blog: {\n          id: '',\n          title: '',\n          content: '',\n          time: '',\n        }\n      }\n    },\n    created() {\n      this.onLoad();\n    },\n    methods: {\n      onLoad() {\n        getList().then(res => {\n          this.data = res.data.data.records;\n          this.page.total = res.data.data.total;\n        })\n      },\n      selectChange(val) {\n        this.multiSelection = val\n      },\n      currentChange(currentPage) {\n        this.page.currentPage = currentPage;\n      },\n      sizeChange(pageSize) {\n        this.page.pageSize = pageSize;\n      },\n      resetForm(formName) {\n        this.$refs[formName].clearValidate()\n      },\n      handleAdd() {\n        this.dialogTitle = '新增博客';\n        this.formVisible = true;\n        console.log(\"add\")\n      },\n      handleView(index, row) {\n        console.log(\"view\");\n        console.log(index);\n        console.log(row);\n      },\n      handleEdit(index, row) {\n        console.log(\"edit\");\n        console.log(index);\n        console.log(row);\n      },\n      handleDelete(index, row) {\n        console.log(\"delete\");\n        console.log(index);\n        console.log(row);\n      },\n      handleMultiDelete() {\n        console.log(\"multi-delete\")\n      },\n      submitBlog(formName) {\n        // 表单验证\n        this.$refs[formName].validate((valid) => {\n          if (valid) {\n            console.log(this.blog);\n            submit(this.blog).then(res => {\n              if (res.data.success) {\n                this.formVisible = false;\n                this.$message({\n                  type: 'success',\n                  message: '操作成功！'\n                })\n              } else {\n                this.$message({\n                  type: 'error',\n                  message: res.data.msg\n                })\n              }\n            })\n          }\n        })\n      },\n    }\n  }\n</script>\n\n<style lang=\"scss\" scoped>\n  .el-pagination {\n    margin-top: 20px;\n  }\n</style>\n\n~~~\n2. 我们来详细分析每一个代码块的作用及目的\n* 如下代码定义了一个dialog组件，并且包裹了表单组件\n~~~\n<el-dialog :title=\"dialogTitle\" width=\"600px\" :visible.sync=\"formVisible\" @close=\"resetForm('blogForm')\">\n  <el-form :model=\"blog\" :rules=\"rules\" ref=\"blogForm\">\n    <el-form-item label=\"标题\" prop=\"title\" label-width=\"55px\">\n      <el-input v-model=\"blog.title\" autocomplete=\"off\"></el-input>\n    </el-form-item>\n    <el-form-item label=\"时间\" label-width=\"55px\">\n      <el-date-picker\n        v-model=\"blog.time\"\n        style=\"width: 100%;\"\n        type=\"date\"\n        value-format=\"yyyy-MM-dd\"\n        placeholder=\"选择日期\"\n        autocomplete=\"off\">\n      </el-date-picker>\n    </el-form-item>\n    <el-form-item label=\"内容\" label-width=\"55px\">\n      <el-input v-model=\"blog.content\" autocomplete=\"off\" type=\"textarea\" :rows=\"5\"></el-input>\n    </el-form-item>\n  </el-form>\n  <div slot=\"footer\" class=\"dialog-footer\">\n    <el-button @click=\"formVisible = false\">取 消</el-button>\n    <el-button type=\"primary\" @click=\"submitBlog('blogForm')\">确 定</el-button>\n  </div>\n</el-dialog>\n~~~\n* 如下的属性分别代表了：绑定标题、设定宽度、设定弹窗可视、设定关闭事件\n~~~\n<el-dialog :title=\"dialogTitle\" width=\"600px\" :visible.sync=\"formVisible\" @close=\"resetForm('blogForm')\">\n~~~\n* 如下的属性分别代表了：绑定form的数据、设定校验规则、定义表单别名\n~~~\n<el-form :model=\"blog\" :rules=\"rules\" ref=\"blogForm\">\n~~~\n* 如下的属性设定了表单内的三个字段：标题、事件、内容\n~~~\n<el-form-item label=\"标题\" prop=\"title\" label-width=\"55px\">\n  <el-input v-model=\"blog.title\" autocomplete=\"off\"></el-input>\n</el-form-item>\n<el-form-item label=\"时间\" label-width=\"55px\">\n  <el-date-picker\n    v-model=\"blog.time\"\n    style=\"width: 100%;\"\n    type=\"date\"\n    value-format=\"yyyy-MM-dd\"\n    placeholder=\"选择日期\"\n    autocomplete=\"off\">\n  </el-date-picker>\n</el-form-item>\n<el-form-item label=\"内容\" label-width=\"55px\">\n  <el-input v-model=\"blog.content\" autocomplete=\"off\" type=\"textarea\" :rows=\"5\"></el-input>\n</el-form-item>\n~~~\n* 如下的属性设置了弹框底部的按钮以及点击事件\n~~~\n<div slot=\"footer\" class=\"dialog-footer\">\n  <el-button @click=\"formVisible = false\">取 消</el-button>\n  <el-button type=\"primary\" @click=\"submitBlog('blogForm')\">确 定</el-button>\n</div>\n~~~\n* 如下的属性设置了vue双向绑定所需要的参数\n~~~\ndata() {\n  return {\n    // 是否显示\n    formVisible: false,\n    // dialog标题\n    dialogTitle: '',\n    // 列表数据\n    data: [],\n    // 选中的数据\n    multiSelection: [],\n    // 分页数据\n    page: {\n      pageSize: 10,\n      currentPage: 1,\n      total: 0\n    },\n    // 校验规则\n    rules: {\n      title: [\n        {required: true, message: '请输入标题', trigger: 'blur'},\n      ]\n    },\n    // 表单映射模型\n    blog: {\n      id: '',\n      title: '',\n      content: '',\n      time: '',\n    }\n  }\n},\n~~~\n* 如下方法定义了表单提交后执行的逻辑\n~~~\nsubmitBlog(formName) {\n  // 表单验证\n  this.$refs[formName].validate((valid) => {\n    if (valid) {\n      console.log(this.blog);\n      submit(this.blog).then(res => {\n        if (res.data.success) {\n          this.formVisible = false;\n          this.$message({\n            type: 'success',\n            message: '操作成功！'\n          })\n        } else {\n          this.$message({\n            type: 'error',\n            message: res.data.msg\n          })\n        }\n      })\n    }\n  })\n},\n~~~\n\n3. 代码分析完毕，我们打开系统查看效果\n![](images/screenshot_1569568894095.png)\n4. 直接提交，发现校验成功\n![](images/screenshot_1569568910139.png)\n5. 填入相关数据，点击确定，查看控制台输出，发现打印信息正确\n![](images/screenshot_1569568972571.png)\n6. 因为采用了mock数据，所以是模拟数据，列表页无法新增数据。我们将在`开发进阶`章节采用前后端分离的模式进行真实数据交互演示\n7. 下一章我们来学习下修改页如何操作\n\n ","title":"新增页"},{"path":"修改页.md","content":"## 修改模块\n1. 我们可以将修改模块与新增模块进行共用，稍作修改，完整代码如下\n~~~\n<template>\n  <basic-container>\n    <el-row>\n      <el-col :span=\"24\">\n        <div class=\"tool-box\">\n          <el-button type=\"primary\" icon=\"el-icon-circle-plus-outline\" size=\"small\" @click=\"handleAdd\">新增</el-button>\n          <el-button type=\"danger\" icon=\"el-icon-delete\" size=\"small\" @click=\"handleMultiDelete\">批量删除</el-button>\n        </div>\n      </el-col>\n    </el-row>\n    <el-row>\n      <el-table\n        :data=\"data\"\n        @selection-change=\"selectChange\"\n        style=\"width: 100%\">\n        <el-table-column\n          prop=\"id\"\n          type=\"selection\"\n          width=\"55\">\n        </el-table-column>\n        <el-table-column\n          hidden\n          prop=\"id\"\n          label=\"主键\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column\n          prop=\"title\"\n          label=\"标题\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column\n          prop=\"content\"\n          label=\"内容\">\n        </el-table-column>\n        <el-table-column\n          prop=\"time\"\n          label=\"日期\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column label=\"操作\" fixed=\"right\" width=\"250\">\n          <template slot-scope=\"scope\">\n            <el-button\n              size=\"mini\"\n              type=\"\"\n              plain\n              @click=\"handleView(scope.$index, scope.row)\">查看\n            </el-button>\n            <el-button\n              size=\"mini\"\n              type=\"primary\"\n              plain\n              @click=\"handleEdit(scope.$index, scope.row)\">编辑\n            </el-button>\n            <el-button\n              size=\"mini\"\n              type=\"danger\"\n              @click=\"handleDelete(scope.$index, scope.row)\">删除\n            </el-button>\n          </template>\n        </el-table-column>\n      </el-table>\n    </el-row>\n    <el-row>\n      <el-pagination\n        background\n        :page-sizes=\"[10, 20, 30, 50]\"\n        :page-size=\"10\"\n        layout=\"total, sizes, prev, pager, next, jumper\"\n        @size-change=\"sizeChange\"\n        @current-change=\"currentChange\"\n        :total=\"page.total\">\n      </el-pagination>\n    </el-row>\n    <el-dialog :title=\"dialogTitle\" width=\"600px\" :visible.sync=\"formVisible\" @close=\"resetForm('blogForm')\">\n      <el-form :model=\"blog\" :rules=\"rules\" ref=\"blogForm\">\n        <el-form-item label=\"标题\" prop=\"title\" label-width=\"55px\">\n          <el-input v-model=\"blog.title\" autocomplete=\"off\"></el-input>\n        </el-form-item>\n        <el-form-item label=\"时间\" label-width=\"55px\">\n          <el-date-picker\n            v-model=\"blog.time\"\n            style=\"width: 100%;\"\n            type=\"date\"\n            value-format=\"yyyy-MM-dd\"\n            placeholder=\"选择日期\"\n            autocomplete=\"off\">\n          </el-date-picker>\n        </el-form-item>\n        <el-form-item label=\"内容\" label-width=\"55px\">\n          <el-input v-model=\"blog.content\" autocomplete=\"off\" type=\"textarea\" :rows=\"5\"></el-input>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"formVisible = false\">取 消</el-button>\n        <el-button type=\"primary\" @click=\"submitBlog('blogForm')\">确 定</el-button>\n      </div>\n    </el-dialog>\n  </basic-container>\n</template>\n\n<script>\n  import {getList, getDetail, submit} from '@/api/demo/blog'\n\n  export default {\n    data() {\n      return {\n        // 是否显示\n        formVisible: false,\n        // dialog标题\n        dialogTitle: '',\n        // 列表数据\n        data: [],\n        // 选中的数据\n        multiSelection: [],\n        // 分页数据\n        page: {\n          pageSize: 10,\n          currentPage: 1,\n          total: 0\n        },\n        // 校验规则\n        rules: {\n          title: [\n            {required: true, message: '请输入标题', trigger: 'blur'},\n          ]\n        },\n        // 表单映射模型\n        blog: {\n          id: '',\n          title: '',\n          content: '',\n          time: '',\n        }\n      }\n    },\n    created() {\n      this.onLoad();\n    },\n    methods: {\n      onLoad() {\n        getList().then(res => {\n          this.data = res.data.data.records;\n          this.page.total = res.data.data.total;\n        })\n      },\n      selectChange(val) {\n        this.multiSelection = val\n      },\n      currentChange(currentPage) {\n        this.page.currentPage = currentPage;\n      },\n      sizeChange(pageSize) {\n        this.page.pageSize = pageSize;\n      },\n      resetForm(formName) {\n        this.$refs[formName].clearValidate()\n      },\n      handleAdd() {\n        this.dialogTitle = '新增博客';\n        this.formVisible = true;\n        console.log(\"add\")\n      },\n      handleView(index, row) {\n        console.log(\"view\");\n        console.log(index);\n        console.log(row);\n      },\n      handleEdit(index, row) {\n        this.dialogTitle = '修改博客';\n        this.formVisible = true;\n        getDetail(row.id).then(res => {\n          if (res.data.success) {\n            this.blog = res.data.data;\n          }\n        });\n        console.log(\"edit\");\n        console.log(index);\n        console.log(row);\n      },\n      handleDelete(index, row) {\n        console.log(\"delete\");\n        console.log(index);\n        console.log(row);\n      },\n      handleMultiDelete() {\n        console.log(\"multi-delete\")\n      },\n      submitBlog(formName) {\n        // 表单验证\n        this.$refs[formName].validate((valid) => {\n          if (valid) {\n            console.log(this.blog);\n            submit(this.blog).then(res => {\n              if (res.data.success) {\n                this.formVisible = false;\n                this.$message({\n                  type: 'success',\n                  message: '操作成功！'\n                })\n              } else {\n                this.$message({\n                  type: 'error',\n                  message: res.data.msg\n                })\n              }\n            })\n          }\n        })\n      },\n    }\n  }\n</script>\n\n<style lang=\"scss\" scoped>\n  .el-pagination {\n    margin-top: 20px;\n  }\n</style>\n\n~~~\n2. 主要变化如下\n* 增加`getDetail`方法\n~~~\n  import {getList, getDetail, submit} from '@/api/demo/blog'\n~~~\n* 修改`handleEdit`方法\n~~~\nhandleEdit(index, row) {\n  this.dialogTitle = '修改博客';\n  this.formVisible = true;\n  getDetail(row.id).then(res => {\n    if (res.data.success) {\n      this.blog = res.data.data;\n    }\n  });\n  console.log(\"edit\");\n  console.log(index);\n  console.log(row);\n},\n~~~\n3. 打开系统刷新页面查看效果\n![](images/screenshot_1569572106765.png)\n4. 详情操作思路与修改一致，需要多一个确定按钮的判断操作，我们来学习下下一章如何操作","title":"修改页"},{"path":"详情页.md","content":"## 详情模块\n1. 加上详情的逻辑，具体代码如下\n~~~\n<template>\n  <basic-container>\n    <el-row>\n      <el-col :span=\"24\">\n        <div class=\"tool-box\">\n          <el-button type=\"primary\" icon=\"el-icon-circle-plus-outline\" size=\"small\" @click=\"handleAdd\">新增</el-button>\n          <el-button type=\"danger\" icon=\"el-icon-delete\" size=\"small\" @click=\"handleMultiDelete\">批量删除</el-button>\n        </div>\n      </el-col>\n    </el-row>\n    <el-row>\n      <el-table\n        :data=\"data\"\n        @selection-change=\"selectChange\"\n        style=\"width: 100%\">\n        <el-table-column\n          prop=\"id\"\n          type=\"selection\"\n          width=\"55\">\n        </el-table-column>\n        <el-table-column\n          prop=\"title\"\n          label=\"标题\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column\n          prop=\"content\"\n          label=\"内容\">\n        </el-table-column>\n        <el-table-column\n          prop=\"time\"\n          label=\"日期\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column label=\"操作\" fixed=\"right\" width=\"250\">\n          <template slot-scope=\"scope\">\n            <el-button\n              size=\"mini\"\n              type=\"\"\n              plain\n              @click=\"handleView(scope.$index, scope.row)\">查看\n            </el-button>\n            <el-button\n              size=\"mini\"\n              type=\"primary\"\n              plain\n              @click=\"handleEdit(scope.$index, scope.row)\">编辑\n            </el-button>\n            <el-button\n              size=\"mini\"\n              type=\"danger\"\n              @click=\"handleDelete(scope.$index, scope.row)\">删除\n            </el-button>\n          </template>\n        </el-table-column>\n      </el-table>\n    </el-row>\n    <el-row>\n      <el-pagination\n        background\n        :page-sizes=\"[10, 20, 30, 50]\"\n        :page-size=\"10\"\n        layout=\"total, sizes, prev, pager, next, jumper\"\n        @size-change=\"sizeChange\"\n        @current-change=\"currentChange\"\n        :total=\"page.total\">\n      </el-pagination>\n    </el-row>\n    <el-dialog :title=\"dialogTitle\" width=\"600px\" :visible.sync=\"formVisible\" @close=\"resetForm('blogForm')\">\n      <el-form :model=\"blog\" :rules=\"rules\" ref=\"blogForm\">\n        <el-form-item label=\"标题\" prop=\"title\" label-width=\"55px\">\n          <el-input v-model=\"blog.title\" autocomplete=\"off\"></el-input>\n        </el-form-item>\n        <el-form-item label=\"时间\" label-width=\"55px\">\n          <el-date-picker\n            v-model=\"blog.time\"\n            style=\"width: 100%;\"\n            type=\"date\"\n            value-format=\"yyyy-MM-dd\"\n            placeholder=\"选择日期\"\n            autocomplete=\"off\">\n          </el-date-picker>\n        </el-form-item>\n        <el-form-item label=\"内容\" label-width=\"55px\">\n          <el-input v-model=\"blog.content\" autocomplete=\"off\" type=\"textarea\" :rows=\"5\"></el-input>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"formVisible = false\">取 消</el-button>\n        <el-button v-if=\"!viewMode\" type=\"primary\" @click=\"submitBlog('blogForm')\">确 定</el-button>\n      </div>\n    </el-dialog>\n  </basic-container>\n</template>\n\n<script>\n  import {getList, getDetail, submit} from '@/api/demo/blog'\n\n  export default {\n    data() {\n      return {\n        // 是否显示\n        formVisible: false,\n        // 是否查看\n        viewMode: false,\n        // dialog标题\n        dialogTitle: '',\n        // 列表数据\n        data: [],\n        // 选中的数据\n        multiSelection: [],\n        // 分页数据\n        page: {\n          pageSize: 10,\n          currentPage: 1,\n          total: 0\n        },\n        // 校验规则\n        rules: {\n          title: [\n            {required: true, message: '请输入标题', trigger: 'blur'},\n          ]\n        },\n        // 表单映射模型\n        blog: {\n          id: '',\n          title: '',\n          content: '',\n          time: '',\n        }\n      }\n    },\n    created() {\n      this.onLoad();\n    },\n    methods: {\n      onLoad() {\n        getList().then(res => {\n          this.data = res.data.data.records;\n          this.page.total = res.data.data.total;\n        })\n      },\n      selectChange(val) {\n        this.multiSelection = val\n      },\n      currentChange(currentPage) {\n        this.page.currentPage = currentPage;\n      },\n      sizeChange(pageSize) {\n        this.page.pageSize = pageSize;\n      },\n      resetForm(formName) {\n        this.$refs[formName].clearValidate()\n      },\n      handleAdd() {\n        this.dialogTitle = '新增博客';\n        this.formVisible = true;\n        this.viewMode = false;\n        console.log(\"add\")\n      },\n      handleView(index, row) {\n        this.dialogTitle = '查看博客';\n        this.formVisible = true;\n        this.viewMode = true;\n        getDetail(row.id).then(res => {\n          if (res.data.success) {\n            this.blog = res.data.data;\n          }\n        });\n        console.log(\"view\");\n        console.log(index);\n        console.log(row);\n      },\n      handleEdit(index, row) {\n        this.dialogTitle = '修改博客';\n        this.formVisible = true;\n        this.viewMode = false;\n        getDetail(row.id).then(res => {\n          if (res.data.success) {\n            this.blog = res.data.data;\n          }\n        });\n        console.log(\"edit\");\n        console.log(index);\n        console.log(row);\n      },\n      handleDelete(index, row) {\n        console.log(\"delete\");\n        console.log(index);\n        console.log(row);\n      },\n      handleMultiDelete() {\n        console.log(\"multi-delete\")\n      },\n      submitBlog(formName) {\n        // 表单验证\n        this.$refs[formName].validate((valid) => {\n          if (valid) {\n            console.log(this.blog);\n            submit(this.blog).then(res => {\n              if (res.data.success) {\n                this.formVisible = false;\n                this.$message({\n                  type: 'success',\n                  message: '操作成功！'\n                })\n              } else {\n                this.$message({\n                  type: 'error',\n                  message: res.data.msg\n                })\n              }\n            })\n          }\n        })\n      },\n    }\n  }\n</script>\n\n<style lang=\"scss\" scoped>\n  .el-pagination {\n    margin-top: 20px;\n  }\n</style>\n\n~~~\n\n2. 主要变化如下\n*  `data()` 方法增加了`viewMode`字段\n~~~\n// 是否查看\nviewMode: false,\n~~~\n* 确定按钮增加判断\n~~~\n<el-button v-if=\"!viewMode\" type=\"primary\" @click=\"submitBlog('blogForm')\">确 定</el-button>\n~~~\n* 新增、修改、查看按钮增加viewMode的操作\n~~~\nhandleAdd() {\n  this.dialogTitle = '新增博客';\n  this.formVisible = true;\n  this.viewMode = false;\n  console.log(\"add\")\n},\nhandleView(index, row) {\n  this.dialogTitle = '查看博客';\n  this.formVisible = true;\n  this.viewMode = true;\n  getDetail(row.id).then(res => {\n    if (res.data.success) {\n      this.blog = res.data.data;\n    }\n  });\n  console.log(\"view\");\n  console.log(index);\n  console.log(row);\n},\nhandleEdit(index, row) {\n  this.dialogTitle = '修改博客';\n  this.formVisible = true;\n  this.viewMode = false;\n  getDetail(row.id).then(res => {\n    if (res.data.success) {\n      this.blog = res.data.data;\n    }\n  });\n  console.log(\"edit\");\n  console.log(index);\n  console.log(row);\n},\n~~~\n\n3. 打开系统刷新页面，发现按钮隐藏成功\n![](images/screenshot_1569572882853.png)","title":"详情页"},{"path":"删除操作.md","content":"## 删除功能\n1. 删除分两处，一处是表格头部可以批量删除的按钮，一处是每一行末尾针对单条数据的删除按钮\n![](images/screenshot_1569572984488.png)\n2. 我们先来实现下简单的单行删除功能\n* api增加remove方法\n~~~\nimport {getList, getDetail, submit, remove} from '@/api/demo/blog'\n~~~\n* 修改handleDelete方法\n~~~\nhandleDelete(index, row) {\n  remove(row.id).then(res => {\n    if (res.data.success) {\n      this.$message({\n        type: 'success',\n        message: '操作成功！'\n      })\n    } else {\n      this.$message({\n        type: 'error',\n        message: res.data.msg\n      })\n    }\n  });\n  console.log(\"delete\");\n  console.log(index);\n  console.log(row);\n},\n~~~\n* 若需要增加确认框，可以修改为如下\n~~~\nhandleDelete(index, row) {\n  this.$confirm(\"确定将选择数据删除?\", {\n    confirmButtonText: \"确定\",\n    cancelButtonText: \"取消\",\n    type: \"warning\"\n  })\n    .then(() => {\n      remove(row.id).then(res => {\n        if (res.data.success) {\n          this.onLoad();\n          this.$message({\n            type: 'success',\n            message: '操作成功！'\n          })\n        } else {\n          this.$message({\n            type: 'error',\n            message: res.data.msg\n          })\n        }\n      });\n    });\n  console.log(\"delete\");\n  console.log(index);\n  console.log(row);\n},\n~~~\n* 测试删除，提示成功（因为使用了mock数据，所以列表数据不会有变化，下一节将会使用真实数据进行演示）\n![](images/screenshot_1569573396595.png)\n![](images/screenshot_1569573415243.png)\n\n3. 现在来实现下多行删除的功能\n\n* 增加computed，定义ids方法\n~~~\ncreated() {\n  this.onLoad();\n},\ncomputed: {\n  ids() {\n    let ids = [];\n    this.multiSelection.forEach(ele => {\n      ids.push(ele.id);\n    });\n    return ids.join(\",\");\n  }\n},\n~~~\n* 修改handleMultiDelete方法\n~~~\nhandleMultiDelete() {\n  console.log(\"multi-delete\");\n  if (this.multiSelection.length === 0) {\n    this.$message.warning(\"请选择至少一条数据\");\n    return;\n  }\n  this.$confirm(\"确定将选择数据删除?\", {\n    confirmButtonText: \"确定\",\n    cancelButtonText: \"取消\",\n    type: \"warning\"\n  })\n    .then(() => {\n      remove(this.ids).then(res => {\n        if (res.data.success) {\n          this.onLoad();\n          this.$message({\n            type: 'success',\n            message: '操作成功！'\n          })\n        } else {\n          this.$message({\n            type: 'error',\n            message: res.data.msg\n          })\n        }\n      });\n    });\n},\n~~~\n* 测试删除，提示成功（因为使用了mock数据，所以列表数据不会有变化，下一节将会使用真实数据进行演示）\n![](images/screenshot_1569574055215.png)\n![](images/screenshot_1569574065007.png)\n![](images/screenshot_1569574249196.png)\n\n* 最后放上完整代码\n~~~\n<template>\n  <basic-container>\n    <el-row>\n      <el-col :span=\"24\">\n        <div class=\"tool-box\">\n          <el-button type=\"primary\" icon=\"el-icon-circle-plus-outline\" size=\"small\" @click=\"handleAdd\">新增</el-button>\n          <el-button type=\"danger\" icon=\"el-icon-delete\" size=\"small\" @click=\"handleMultiDelete\">批量删除</el-button>\n        </div>\n      </el-col>\n    </el-row>\n    <el-row>\n      <el-table\n        :data=\"data\"\n        @selection-change=\"selectChange\"\n        style=\"width: 100%\">\n        <el-table-column\n          prop=\"id\"\n          type=\"selection\"\n          width=\"55\">\n        </el-table-column>\n        <el-table-column\n          prop=\"title\"\n          label=\"标题\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column\n          prop=\"content\"\n          label=\"内容\">\n        </el-table-column>\n        <el-table-column\n          prop=\"time\"\n          label=\"日期\"\n          width=\"180\">\n        </el-table-column>\n        <el-table-column label=\"操作\" fixed=\"right\" width=\"250\">\n          <template slot-scope=\"scope\">\n            <el-button\n              size=\"mini\"\n              type=\"\"\n              plain\n              @click=\"handleView(scope.$index, scope.row)\">查看\n            </el-button>\n            <el-button\n              size=\"mini\"\n              type=\"primary\"\n              plain\n              @click=\"handleEdit(scope.$index, scope.row)\">编辑\n            </el-button>\n            <el-button\n              size=\"mini\"\n              type=\"danger\"\n              @click=\"handleDelete(scope.$index, scope.row)\">删除\n            </el-button>\n          </template>\n        </el-table-column>\n      </el-table>\n    </el-row>\n    <el-row>\n      <el-pagination\n        background\n        :page-sizes=\"[10, 20, 30, 50]\"\n        :page-size=\"10\"\n        layout=\"total, sizes, prev, pager, next, jumper\"\n        @size-change=\"sizeChange\"\n        @current-change=\"currentChange\"\n        :total=\"page.total\">\n      </el-pagination>\n    </el-row>\n    <el-dialog :title=\"dialogTitle\" width=\"600px\" :visible.sync=\"formVisible\" @close=\"resetForm('blogForm')\">\n      <el-form :model=\"blog\" :rules=\"rules\" ref=\"blogForm\">\n        <el-form-item label=\"标题\" prop=\"title\" label-width=\"55px\">\n          <el-input v-model=\"blog.title\" autocomplete=\"off\"></el-input>\n        </el-form-item>\n        <el-form-item label=\"时间\" label-width=\"55px\">\n          <el-date-picker\n            v-model=\"blog.time\"\n            style=\"width: 100%;\"\n            type=\"date\"\n            value-format=\"yyyy-MM-dd\"\n            placeholder=\"选择日期\"\n            autocomplete=\"off\">\n          </el-date-picker>\n        </el-form-item>\n        <el-form-item label=\"内容\" label-width=\"55px\">\n          <el-input v-model=\"blog.content\" autocomplete=\"off\" type=\"textarea\" :rows=\"5\"></el-input>\n        </el-form-item>\n      </el-form>\n      <div slot=\"footer\" class=\"dialog-footer\">\n        <el-button @click=\"formVisible = false\">取 消</el-button>\n        <el-button v-if=\"!viewMode\" type=\"primary\" @click=\"submitBlog('blogForm')\">确 定</el-button>\n      </div>\n    </el-dialog>\n  </basic-container>\n</template>\n\n<script>\n  import {getList, getDetail, submit, remove} from '@/api/demo/blog'\n\n  export default {\n    data() {\n      return {\n        // 是否显示\n        formVisible: false,\n        // 是否查看\n        viewMode: false,\n        // dialog标题\n        dialogTitle: '',\n        // 列表数据\n        data: [],\n        // 选中的数据\n        multiSelection: [],\n        // 分页数据\n        page: {\n          pageSize: 10,\n          currentPage: 1,\n          total: 0\n        },\n        // 校验规则\n        rules: {\n          title: [\n            {required: true, message: '请输入标题', trigger: 'blur'},\n          ]\n        },\n        // 表单映射模型\n        blog: {\n          id: '',\n          title: '',\n          content: '',\n          time: '',\n        }\n      }\n    },\n    created() {\n      this.onLoad();\n    },\n    computed: {\n      ids() {\n        let ids = [];\n        this.multiSelection.forEach(ele => {\n          ids.push(ele.id);\n        });\n        return ids.join(\",\");\n      }\n    },\n    methods: {\n      onLoad() {\n        getList().then(res => {\n          this.data = res.data.data.records;\n          this.page.total = res.data.data.total;\n        })\n      },\n      selectChange(val) {\n        this.multiSelection = val;\n        console.log(this.multiSelection);\n      },\n      currentChange(currentPage) {\n        this.page.currentPage = currentPage;\n      },\n      sizeChange(pageSize) {\n        this.page.pageSize = pageSize;\n      },\n      resetForm(formName) {\n        this.$refs[formName].clearValidate()\n      },\n      handleAdd() {\n        this.dialogTitle = '新增博客';\n        this.formVisible = true;\n        this.viewMode = false;\n        console.log(\"add\")\n      },\n      handleView(index, row) {\n        this.dialogTitle = '查看博客';\n        this.formVisible = true;\n        this.viewMode = true;\n        getDetail(row.id).then(res => {\n          if (res.data.success) {\n            this.blog = res.data.data;\n          }\n        });\n        console.log(\"view\");\n        console.log(index);\n        console.log(row);\n      },\n      handleEdit(index, row) {\n        this.dialogTitle = '修改博客';\n        this.formVisible = true;\n        this.viewMode = false;\n        getDetail(row.id).then(res => {\n          if (res.data.success) {\n            this.blog = res.data.data;\n          }\n        });\n        console.log(\"edit\");\n        console.log(index);\n        console.log(row);\n      },\n      handleDelete(index, row) {\n        this.$confirm(\"确定将选择数据删除?\", {\n          confirmButtonText: \"确定\",\n          cancelButtonText: \"取消\",\n          type: \"warning\"\n        })\n          .then(() => {\n            remove(row.id).then(res => {\n              if (res.data.success) {\n                this.onLoad();\n                this.$message({\n                  type: 'success',\n                  message: '操作成功！'\n                })\n              } else {\n                this.$message({\n                  type: 'error',\n                  message: res.data.msg\n                })\n              }\n            });\n          });\n        console.log(\"delete\");\n        console.log(index);\n        console.log(row);\n      },\n      handleMultiDelete() {\n        console.log(\"multi-delete\");\n        if (this.multiSelection.length === 0) {\n          this.$message.warning(\"请选择至少一条数据\");\n          return;\n        }\n        this.$confirm(\"确定将选择数据删除?\", {\n          confirmButtonText: \"确定\",\n          cancelButtonText: \"取消\",\n          type: \"warning\"\n        })\n          .then(() => {\n            remove(this.ids).then(res => {\n              if (res.data.success) {\n                this.onLoad();\n                this.$message({\n                  type: 'success',\n                  message: '操作成功！'\n                })\n              } else {\n                this.$message({\n                  type: 'error',\n                  message: res.data.msg\n                })\n              }\n            });\n          });\n      },\n      submitBlog(formName) {\n        // 表单验证\n        this.$refs[formName].validate((valid) => {\n          if (valid) {\n            console.log(this.blog);\n            submit(this.blog).then(res => {\n              if (res.data.success) {\n                this.formVisible = false;\n                this.$message({\n                  type: 'success',\n                  message: '操作成功！'\n                })\n              } else {\n                this.$message({\n                  type: 'error',\n                  message: res.data.msg\n                })\n              }\n            })\n          }\n        })\n      },\n    }\n  }\n</script>\n\n<style lang=\"scss\" scoped>\n  .el-pagination {\n    margin-top: 20px;\n  }\n</style>\n\n~~~\n\n\n## 后记\n* 基于ElementUI做的最简单的CRUD模块已经讲解完毕，希望大家后续可以继续深入研究，能够使用原生ElementUI进行开发。\n* 当然，我们有基于Element UI二次封装的框架Avue，不仅封装、简化了很多模块的操作，也100%兼容ElementUI，更是采用了Json驱动进行页面模块渲染，大大节约了前端构建的时间\n* 下面一节，我们将学习Avue为我们带来的极速开发效率，并且以一个前后端分离的模块进行实战讲解\n ","title":"删除操作"},{"path":"开发进阶.md","content":"[API反向代理](API%E5%8F%8D%E5%90%91%E4%BB%A3%E7%90%86.md)\n[Avue组件](Avue%E7%BB%84%E4%BB%B6.md)\n[基于Avue改造CRUD](%E5%9F%BA%E4%BA%8EAvue%E6%94%B9%E9%80%A0CRUD.md)\n","title":"开发进阶"},{"path":"API反向代理.md","content":"## 什么是反向代理\n反向代理是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。\n\n## 为什么要用反向代理\n前端与后端接口对接的时候，若只使用完整的api链接，或者后端api不做处理的话，会造成跨域。从而无法正常调用到接口。这时候就需要将接口代理到本地以此来消除跨域生成的条件，这样一来就可以顺利调用api了。\n## 如何使用反向代理\n* 找到vue.config.js，大家可以自行定义相关配置\n* port为saber启动后占用的端口（若已经被使用，则会自动+1）\n* target则代表需要反向代理的地址\n* 若原先的接口地址为`http://localhost/token`，经过反向代理后，则会变成`http://localhost:1888/api/token`\n* 这样一来，将外部的接口代理到前端本地，这样就不会存在跨域的情况了\n* 同理部署在生产服务器上时，使用nginx进行反向代理的配置，同样能轻松解决跨域带来的问题\n![](images/screenshot_1569574549110.png)\n","title":"API反向代理"},{"path":"Avue组件.md","content":"[官网](%E5%AE%98%E7%BD%91.md)\n[表格组件](%E8%A1%A8%E6%A0%BC%E7%BB%84%E4%BB%B6.md)\n[表单组件](%E5%88%97%E8%A1%A8%E7%BB%84%E4%BB%B6.md)\n[其他组件](%E5%85%B6%E4%BB%96%E7%BB%84%E4%BB%B6.md)\n","title":"Avue组件"},{"path":"官网.md","content":"## Avue官网\nAvue.js2.0是基于现有的element-ui库进行的二次封装，简化一些繁琐的操作，核心理念为数据驱动视图,主要的组件库针对table表格和form表单场景，同时衍生出更多企业常用的组件，达到高复用，容易维护和扩展的框架，同时内置了丰富了数据展示组件，让开发变得更加容易。\n\n## 学习资料\n* Avue官网：[https://avuejs.com](https://avuejs.com)\n* Avue官方文档：[https://avuejs.com/doc/installation](https://avuejs.com/doc/installation)","title":"官网"},{"path":"表格组件.md","content":"## 表格组件\n* 组件文档：[https://avuejs.com/doc/crud/crud-doc](https://avuejs.com/doc/crud/crud-doc)\n* 可以看到，官网的组件文档非常全，查看对应例子\n![](images/screenshot_1569579357070.png)\n![](images/screenshot_1569579373156.png)\n![](images/screenshot_1569579387998.png)\n* 找一个基础的demo，进行集成\n![](images/screenshot_1569579817239.png)\n* 将代码拷贝至最开始的demo.vue文件\n![](images/screenshot_1569579845358.png)\n* 刷新页面查看效果，发现已经完整展现了crud功能\n![](images/screenshot_1569579879422.png)\n![](images/screenshot_1569579893666.png)\n![](images/screenshot_1569579902337.png)\n![](images/screenshot_1569579910692.png)\n![](images/screenshot_1569579920132.png)\n* 有些情况，默认的配置无法满足我们的要求，比需要给字典项加上背景来突出显示，这时候我们可以通过卡槽来定义\n![](images/screenshot_1569587861574.png)\n* 再次刷新页面，发现表格的自定义卡槽生效（表单的自定义卡槽将在下一章介绍）\n![](images/screenshot_1569587903301.png)\n* 与之前的ElementUI原生写法相对比，avue的方式为我们省了很多精力。几乎所有的操作都使用json驱动配置就能实现我们想要的效果\n* 具体的配置，我们可以查看文档与例子进行拓展：[https://avuejs.com/doc/crud/crud-doc](https://avuejs.com/doc/crud/crud-doc)\n\n\n","title":"表格组件"},{"path":"列表组件.md","content":"## 表单组件\n* 组件文档：[https://avuejs.com/doc/form/form-doc](https://avuejs.com/doc/form/form-doc)\n* 查看对应例子\n![](images/screenshot_1569587038657.png)\n![](images/screenshot_1569587049260.png)\n![](images/screenshot_1569587071797.png)\n* 找一个基础的demo，进行集成\n![](images/screenshot_1569587115885.png)\n* 将代码拷贝至最开始的demo.vue文件\n![](images/screenshot_1569587163777.png)\n* 刷新页面点击提交，发现表单数据获取成功\n![](images/screenshot_1569587200278.png)\n* 由此可见，avue的表格、表单组件都只需要配置`option`，便可以渲染出各种我们所需要的效果。若某些情况不支持，我们也可以使用slot卡槽进行配置。\n* 在column中配置formslot属性，同时在<avue-form>标签内配置template卡槽，`column`的`prop`需要与卡槽的`slot`对应\n![](images/screenshot_1569587462900.png)\n* 刷新页面发现卡槽定义成功\n![](images/screenshot_1569587561166.png)\n* 这样一来，大家便可以通过卡槽来配置出各种复杂场景的组件了","title":"表单组件"},{"path":"其他组件.md","content":"## 其他组件介绍\n* 除了表格组件和表单组件之外，avue还有其他非常好用的组件\n ![](images/screenshot_1569587977756.png)\n* 拥有各种数据展示模板\n![](images/screenshot_1569588004384.png)\n* 拥有各种网上搜索率极高但是又鲜有完美解决方案的组件\n![](images/screenshot_1569588083823.png)\n![](images/screenshot_1569588051859.png)\n![](images/screenshot_1569588144145.png)\n* 更多操作，等待大家发掘～～","title":"其他组件"},{"path":"基于Avue改造CRUD.md","content":"[数据库建表](%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BB%BA%E8%A1%A8.md)\n[代码生成](%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90.md)\n[前端配置](%E5%89%8D%E7%AB%AF%E9%85%8D%E7%BD%AE.md)\n[优化效果](%E4%BC%98%E5%8C%96%E6%95%88%E6%9E%9C.md)\n","title":"基于Avue改造CRUD"},{"path":"数据库建表.md","content":"## 创建业务表\n1. 设定表字段\n![](images/screenshot_1569589615572.png)\n2. 设定表名\n![](images/screenshot_1569589492056.png)\n3. 红框部分的字段为业务通用字段，非常有用，推荐大家加上\n![](images/screenshot_1569589675596.png)","title":"数据库建表"},{"path":"代码生成.md","content":"## 代码生成配置\n1. 重启后端工程\n![](images/screenshot_1569589744974.png)\n2. 打开前端`研发工具`->`数据源管理` 配置数据源\n![](images/screenshot_1569589818111.png)\n3. 打开前端`研发工具`->`代码生成` 配置代码生成方案\n4. 为了快速配置，我们可以点击复制按钮\n![](images/screenshot_1569589897033.png)\n5. 对复制出来的配置进行修改\n![](images/screenshot_1569589919363.png)\n![](images/screenshot_1569590034411.png)\n6. 下面对各个属性进行讲解\n* 数据源：在数据源管理中的配置，用于选择从对应的库获取数据\n* 模块名：用于指定配置的名称，对代码生成不产生实际效果\n* 服务名：生成后，controller对应的前缀，以及分割`-`符号后面的字符串作为前端的分包名\n* 表名：用于代码生成所对应的表名称\n* 表前缀：生成实体类的时候，忽略掉的前缀，若不配置，则`tb_blog`表生成的实体为`TbBlog`，若配置了`tb_`为前缀，则生成的实体为Blog\n* 主键名：表的主键名称\n* 包名：生成后端代码所在的包\n* 基础业务：如果选择是，则实体会继承`BaseEntity`，带有上一章红框的基础业务字段\n* 包装器：在某些复杂的模块，会用到`VO`和`Wrapper`，如果选择是则会自行生成\n* 后端生成路径：后端工程的根目录\n* 前端生成路径：前端工程的根目录\n\n## 执行代码生成\n1. 选择刚刚的配置，点击代码生成\n![](images/screenshot_1569590630549.png)\n![](images/screenshot_1569590663611.png)\n2. 查看后端代码，发现已经按照我们的配置，生成了后端的整套代码\n![](images/screenshot_1569590712813.png)\n3. 同时生成了一个菜单的sql文件，将增删改查整个模块的sql脚本都生成好了（因为我们之前已经手动建好了对应的菜单，所以这次无需执行脚本，将其删掉即可）\n![](images/screenshot_1569590763101.png)\n4. 再次重启后端代码\n![](images/screenshot_1569590827706.png)\n5. 后端已经搞定，我们下一章来看一下前端的配置\n\n","title":"代码生成"},{"path":"前端配置.md","content":"## 前端配置\n1. 切回前端工程，发现我们之前做demo的`/api/demo/blog.js`和`/views/demo/blog.vue`两个文件已经被代码生成覆盖完毕\n![](images/screenshot_1569590968318.png)\n![](images/screenshot_1569590975431.png)\n![](images/screenshot_1569590987505.png)\n![](images/screenshot_1569591000404.png)\n![](images/screenshot_1569591011201.png)\n\n2. 重启前端工程，访问菜单的测试模块，发现已经出现对应界面\n![](images/screenshot_1569591437934.png)","title":"前端配置"},{"path":"优化效果.md","content":"## 优化前端效果\n1. 点击新增，发现都为text类型，时间不是组件，内容也不是文本域，还多处了主键字段。\n![](images/screenshot_1569591462949.png)\n2. 因为代码生成默认的表单控件属性为text，所以针对一些组件，我们需要进行手动配置，就这个模块而言，我们需要删掉id和配置content字段和time字段的组件属性\n![](images/screenshot_1569591149587.png)\n![](images/screenshot_1569591235687.png)\n3. 刷新页面再次打开新增，发现组件类型正确，但是布局并不是很好看\n![](images/screenshot_1569591502966.png)\n4. 我们把时间挪上去，发现排列美观了\n![](images/screenshot_1569591540797.png)\n![](images/screenshot_1569591558224.png)\n5. 如果想每个控件占用一行，我们可以如此配置\n![](images/screenshot_1569591596918.png)\n![](images/screenshot_1569591607965.png)\n6. 如果觉得弹框太高，我们可以进行高度设置\n![](images/screenshot_1569591662888.png)\n![](images/screenshot_1569591678975.png)\n7. 这样一来，界面就美观多了\n\n## 新增测试\n* 输入相应的值，点击保存，提示成功\n![](images/screenshot_1569591745739.png)\n\n## 查看测试\n* 点击查看，数据加载无误\n![](images/screenshot_1569591790807.png)\n\n## 编辑测试\n* 点击编辑，并修改一条数据，修改也成功\n![](images/screenshot_1569591833037.png)\n![](images/screenshot_1569591842284.png)\n\n## 删除测试\n* 将刚刚新增的数据删除，提示成功\n![](images/screenshot_1569591875604.png)\n\n## 分页测试\n* 手动新增11条数据，发现分页成功\n![](images/screenshot_1569591996889.png)\n![](images/screenshot_1569592015751.png)\n\n## 查询测试\n* 在标题的字段上增加属性\n![](images/screenshot_1569592052841.png)\n* 刷新页面，可以看到出现了对应的搜索框\n![](images/screenshot_1569592081876.png)\n* 随意输入一个标题，点击查询，发现查询成功\n![](images/screenshot_1569592109428.png)\n\n## 后记\n* 由此可见，我们通过一个简单的配置，便迅速生成了前后端分离模式下的完整增删改查功能\n* 文档讲解只是小部分知识点，更多的操作有待大家去发掘\n* 相信大家看完SpringBlade+Saber两套框架后，会享受到更加极速的开发体验～\n\n","title":"优化效果"},{"path":"构建发布.md","content":"[项目构建](%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA.md)\n[项目发布](%E9%A1%B9%E7%9B%AE%E5%8F%91%E5%B8%83.md)\n","title":"构建发布"},{"path":"项目构建.md","content":"## 构建步骤\n1. Saber基于vue-cli构建，所以打包很简单，只需在根目录下执行`yarn run build`即可\n2. 在Saber根目录下执行命令，提示成功后可以看到根目录下多了一个dist文件夹，里面的便是已经打包完毕的文件了\n![](images/screenshot_1569592359549.png)\n3. 除此之外，webstorm也可以通过命令快速执行构建\n4. 点开边上的`npm`，点击`build`选项，同样可以进入构建\n![](images/screenshot_1569592410995.png)\n![](images/screenshot_1569592435445.png)\n![](images/screenshot_1569592447037.png)\n","title":"项目构建"},{"path":"项目发布.md","content":"## 项目发布\n1. 我们一般会选择将前端打包后的文件放到nginx中\n2. 把文件放到nginx的html目录下，同时配置反向代理，若有多个后端，可以做负载均衡\n![](images/screenshot_1569592525649.png)\n3. 放出文本配置，方便大家拷贝\n~~~\n\nuser  root;\nworker_processes  1;\n\nerror_log  /var/log/nginx/error.log warn;\npid        /var/run/nginx.pid;\n\n\nevents {\n    worker_connections  1024;\n}\n\n\nhttp {\n    include       /etc/nginx/mime.types;\n    default_type  application/octet-stream;\n\n    log_format  main  '$remote_addr - $remote_user [$time_local] \"$request\" '\n                      '$status $body_bytes_sent \"$http_referer\" '\n                      '\"$http_user_agent\" \"$http_x_forwarded_for\"';\n\n    access_log  /var/log/nginx/access.log  main;\n\n    sendfile        on;\n    #tcp_nopush     on;\n\n    keepalive_timeout  65;\n\n    #gzip  on;\n\n    #include /etc/nginx/conf.d/*.conf;\n\n    upstream gateway {\n                 server 172.30.0.81;\n                 server 172.30.0.82;\n                 server 172.30.0.83;\n             }\n\n\n    server {\n      listen       8000;\n      server_name  web;\n      root         /usr/share/nginx/html;\n\n      location / {\n\n      }\n\n      location ^~/api {\n           proxy_set_header Host $host;\n           proxy_set_header X-Real-IP $remote_addr;\n           proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n           proxy_buffering off;\n           rewrite ^/api/(.*)$ /$1 break;\n           proxy_pass http://gateway;\n      }\n    }\n\n\n}\n\n~~~","title":"项目发布"},{"path":"后记.md","content":"[BladeX介绍](BladeX%E4%BB%8B%E7%BB%8D.md)\n[技术社区](%E6%8A%80%E6%9C%AF%E7%A4%BE%E5%8C%BA.md)\n[常见问题](%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98.md)\n","title":"后记"},{"path":"BladeX介绍.md","content":"## BladeX 是什么\n* BladeX是SpringBlade、Saber的商业版本\n* BladeX的代码核心、功能、组件都做了升级，他是一个更适合企业生产的基础框架\n* 购买 BladeX 授权可减免本文档金额60元\n* 授权地址：https://bladex.vip/#/vip\n* 授权须知：https://bladex.vip/#/doc/notice\n* 演示地址：[https://saber.bladex.vip](https://saber.bladex.vip)\n<br>\n## BladeX 未来支持功能一览\n\n![](images/screenshot_1569592714790.png)\n![](images/screenshot_1569592736740.png)\n<br>\n\n## 为什么需要 BladeX\n1\\. 经历过较长的线上生产，积累了很多企业痛点的解决方案。  \n2\\. 集成了很多企业急切所需的例如多租户、Oauth2授权认证、工作流、分布式事务等等功能。\n3\\.深度定制了Flowable工作流，完美支持SpringCloud分布式服务的场景，以远程调用的方式进行操作。\n4\\. 升级了核心驱动，新功能完全可以开箱即用，而开源版需要自己再花时间进行集成，需要花掉更多的时间成本。  \n5\\. 拥抱微服务时代，很多企业由于项目转型或升级，传统的技术已然不能满足，反而会花更多成本，而BladeX就是为此而生。  \n6\\. 同时提供SpringCloud版本和SpringBoot版本，两个版本的api可以与Sword和Saber无缝对接，为小型项目至大型项目保驾护航。  \n7\\. 授权购买即永久，源码没有混淆，完全开放，后续升级完全免费。企业只需花很少的钱即可获得一整套成熟的解决方案，你还在等什么？\n<br>\n","title":"BladeX介绍"},{"path":"技术社区.md","content":"* blade问答社区地址：[https://sns.bladex.vip/](https://sns.bladex.vip/)\n* 若有使用疑问欢迎大家前往提问交流\n\n![](images/screenshot_1569592901749.png)\n","title":"技术社区"},{"path":"常见问题.md","content":"* **Blade问答社区建立以来已经解决了数以百计的问题，为了让大家更快的排坑，特将常见的问题收录，供大家快速查阅。**\n* 问题收录地址：[https://sns.bladex.vip/article-14966.html](https://sns.bladex.vip/article-14966.html)","title":"常见问题"}]